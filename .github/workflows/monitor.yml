name: Monitor

on:
  schedule:
    # 每5分钟运行一次
    - cron: '*/5 * * * *'
  workflow_dispatch: # 允许手动触发测试

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check and Notify
        env:
          EMAIL_TO: ${{ secrets.EMAIL_TO }}
          EMAIL_FROM: ${{ secrets.EMAIL_FROM }}
          EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}
          TARGET_USER: ${{ secrets.TARGET_USER }}
        run: |
          pip install requests beautifulsoup4 > /dev/null 2>&1
          python3 << 'PYEOF'
          import requests
          import smtplib
          import os
          import json
          import re
          from email.mime.text import MIMEText

          target_user = os.environ.get("TARGET_USER", "")
          
          # 使用 nitter 实例来获取推文（因为直接访问x.com需要登录）
          nitter_instances = [
              f"https://nitter.net/{target_user}",
              f"https://nitter.privacydev.net/{target_user}",
              f"https://nitter.poast.org/{target_user}",
          ]
          
          # 备用方案：使用 syndication API
          syndication_url = f"https://syndication.twitter.com/srv/timeline-profile/screen-name/{target_user}"
          
          html = ""
          source = ""
          
          headers = {
              "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
              "Accept": "text/html,application/xhtml+xml",
              "Accept-Language": "en-US,en;q=0.9",
          }
          
          # 先尝试 syndication API
          try:
              resp = requests.get(syndication_url, headers=headers, timeout=30)
              if resp.status_code == 200 and len(resp.text) > 100:
                  html = resp.text
                  source = "syndication"
                  print("使用 syndication API 成功")
          except Exception as e:
              print(f"syndication 失败: {e}")
          
          # 如果失败，尝试 nitter
          if not html:
              for nitter_url in nitter_instances:
                  try:
                      resp = requests.get(nitter_url, headers=headers, timeout=30)
                      if resp.status_code == 200 and len(resp.text) > 100:
                          html = resp.text
                          source = "nitter"
                          print(f"使用 {nitter_url} 成功")
                          break
                  except Exception as e:
                      print(f"{nitter_url} 失败: {e}")
                      continue
          
          if not html:
              print("所有数据源都失败了")
              exit(0)
          
          # 提取推文链接
          tweet_links = re.findall(
              rf'/{target_user}/status/(\d+)',
              html,
              re.IGNORECASE
          )
          
          # 去重，保留前3条
          seen = []
          for tid in tweet_links:
              if tid not in seen:
                  seen.append(tid)
              if len(seen) >= 3:
                  break
          
          current_tweets = seen
          print(f"当前检测到的推文ID: {current_tweets}")
          
          # 读取上次保存的推文ID
          history_file = "last_tweets.json"
          old_tweets = []
          if os.path.exists(history_file):
              with open(history_file, "r") as f:
                  old_tweets = json.load(f)
          
          print(f"上次保存的推文ID: {old_tweets}")
          
          # 找出新推文
          new_tweets = [t for t in current_tweets if t not in old_tweets]
          
          if new_tweets:
              print(f"发现 {len(new_tweets)} 条新推文!")
              
              # 构建邮件内容，只有URL
              links = []
              for tid in new_tweets:
                  links.append(f"https://x.com/i/status/{tid}")
              
              body = "检测到新内容:\n\n" + "\n".join(links)
              
              # 发邮件
              email_to = os.environ.get("EMAIL_TO", "")
              email_from = os.environ.get("EMAIL_FROM", "")
              email_password = os.environ.get("EMAIL_PASSWORD", "")
              
              if email_to and email_from and email_password:
                  try:
                      msg = MIMEText(body, "plain", "utf-8")
                      msg["Subject"] = "页面更新通知"
                      msg["From"] = email_from
                      msg["To"] = email_to
                      
                      server = smtplib.SMTP_SSL("smtp.gmail.com", 465)
                      server.login(email_from, email_password)
                      server.sendmail(email_from, email_to, msg.as_string())
                      server.quit()
                      print("邮件已发送")
                  except Exception as e:
                      print(f"邮件发送失败: {e}")
              else:
                  print("邮箱未配置，跳过发送")
                  print(f"新推文链接:\n{body}")
          else:
              print("没有新推文")
          
          # 保存当前推文ID
          with open(history_file, "w") as f:
              json.dump(current_tweets, f)
          
          PYEOF

      - name: Save State
        if: always()
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add last_tweets.json 2>/dev/null || true
          git diff --cached --quiet || git commit -m "update state"
          git push || true
