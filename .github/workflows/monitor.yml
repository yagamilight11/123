name: Monitor

on:
  schedule:
    - cron: '*/2 * * * *'
  workflow_dispatch:

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Dependencies
        run: pip install selenium > /dev/null 2>&1

      - name: Setup Chrome
        uses: browser-actions/setup-chrome@v1
        with:
          chrome-version: stable

      - name: Setup ChromeDriver
        uses: nanasess/setup-chromedriver@v2

      - name: Check and Notify
        env:
          EMAIL_TO: ${{ secrets.EMAIL_TO }}
          EMAIL_FROM: ${{ secrets.EMAIL_FROM }}
          EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}
          TARGET_USER: ${{ secrets.TARGET_USER }}
        run: |
          python3 << 'PYEOF'
          import os
          import json
          import re
          import smtplib
          import time
          import random
          from email.mime.text import MIMEText
          from selenium import webdriver
          from selenium.webdriver.chrome.options import Options
          from selenium.webdriver.common.by import By

          target_user = os.environ.get("TARGET_USER", "")
          tweet_ids = []

          def create_driver():
              options = Options()
              options.add_argument("--headless=new")
              options.add_argument("--no-sandbox")
              options.add_argument("--disable-dev-shm-usage")
              options.add_argument("--disable-gpu")
              options.add_argument("--disable-blink-features=AutomationControlled")
              options.add_argument("--window-size=1920,1080")
              options.add_argument("--lang=en-US")
              options.add_argument("--disable-extensions")
              options.add_argument("--disable-infobars")
              ua = random.choice([
                  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
                  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
                  "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
              ])
              options.add_argument(f"user-agent={ua}")
              options.add_experimental_option("excludeSwitches", ["enable-automation"])
              options.add_experimental_option("useAutomationExtension", False)
              driver = webdriver.Chrome(options=options)
              driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
              driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument", {
                  "source": """
                      Object.defineProperty(navigator, 'webdriver', {get: () => undefined});
                      Object.defineProperty(navigator, 'plugins', {get: () => [1, 2, 3]});
                      Object.defineProperty(navigator, 'languages', {get: () => ['en-US', 'en']});
                      window.chrome = { runtime: {} };
                  """
              })
              return driver

          def try_direct(user):
              """直接访问用户主页"""
              driver = create_driver()
              try:
                  url = f"https://x.com/{user}"
                  print(f"直接访问: {url}")
                  driver.get(url)
                  time.sleep(15)
                  html = driver.page_source
                  print(f"页面长度: {len(html)}")
                  
                  if "login" in html.lower()[:5000] and len(html) < 400000:
                      print("检测到登录墙")
                      return []
                  
                  matches = re.findall(r'/status/(\d{15,25})', html)
                  
                  if not matches:
                      try:
                          links = driver.find_elements(By.CSS_SELECTOR, 'a[href*="/status/"]')
                          for link in links:
                              href = link.get_attribute("href") or ""
                              m = re.search(r'/status/(\d{15,25})', href)
                              if m:
                                  matches.append(m.group(1))
                      except:
                          pass
                  
                  print(f"匹配数: {len(matches)}")
                  return matches
              except Exception as e:
                  print(f"直接访问失败: {e}")
                  return []
              finally:
                  driver.quit()

          def try_search(user):
              """通过搜索页面获取"""
              driver = create_driver()
              try:
                  url = f"https://x.com/search?q=from%3A{user}&src=typed_query&f=live"
                  print(f"搜索访问: {url}")
                  driver.get(url)
                  time.sleep(15)
                  html = driver.page_source
                  print(f"搜索页面长度: {len(html)}")
                  matches = re.findall(r'/status/(\d{15,25})', html)
                  print(f"搜索匹配数: {len(matches)}")
                  return matches
              except Exception as e:
                  print(f"搜索失败: {e}")
                  return []
              finally:
                  driver.quit()

          def try_embed(user):
              """通过嵌入页面获取"""
              driver = create_driver()
              try:
                  url = f"https://syndication.twitter.com/srv/timeline-profile/screen-name/{user}"
                  print(f"嵌入访问: {url}")
                  driver.get(url)
                  time.sleep(10)
                  html = driver.page_source
                  print(f"嵌入页面长度: {len(html)}")
                  matches = re.findall(r'/status/(\d{15,25})', html)
                  print(f"嵌入匹配数: {len(matches)}")
                  return matches
              except Exception as e:
                  print(f"嵌入失败: {e}")
                  return []
              finally:
                  driver.quit()

          # 依次尝试3种方法
          print("=== 方法1: 直接访问 ===")
          all_matches = try_direct(target_user)

          if not all_matches:
              print("\n=== 方法2: 搜索页面 ===")
              all_matches = try_search(target_user)

          if not all_matches:
              print("\n=== 方法3: 嵌入页面 ===")
              all_matches = try_embed(target_user)

          # 去重保留前5条
          seen = []
          for tid in all_matches:
              if tid not in seen:
                  seen.append(tid)
              if len(seen) >= 5:
                  break

          tweet_ids = seen
          print(f"\n最终推文ID: {tweet_ids}")

          if not tweet_ids:
              print("本次未获取到推文，等待下次重试")
              exit(0)

          # 读取历史
          history_file = "last_tweets.json"
          old_tweets = []
          first_run = False

          if os.path.exists(history_file):
              with open(history_file, "r") as f:
                  old_tweets = json.load(f)
          else:
              first_run = True

          print(f"上次推文ID: {old_tweets}")

          new_tweets = [t for t in tweet_ids if t not in old_tweets]
          should_send = first_run or len(new_tweets) > 0

          if should_send:
              links = [f"https://x.com/i/status/{tid}" for tid in (new_tweets if new_tweets else tweet_ids)]
              if first_run:
                  body = "监控已启动:\n\n" + "\n".join(links)
              else:
                  body = "检测到新内容:\n\n" + "\n".join(links)

              email_to = os.environ.get("EMAIL_TO", "")
              email_from = os.environ.get("EMAIL_FROM", "")
              email_password = os.environ.get("EMAIL_PASSWORD", "")

              if email_to and email_from and email_password:
                  try:
                      msg = MIMEText(body, "plain", "utf-8")
                      msg["Subject"] = "页面更新通知"
                      msg["From"] = email_from
                      msg["To"] = email_to

                      server = smtplib.SMTP_SSL("smtp.gmail.com", 465)
                      server.login(email_from, email_password)
                      server.sendmail(email_from, email_to, msg.as_string())
                      server.quit()
                      print("邮件已发送")
                  except Exception as e:
                      print(f"邮件发送失败: {e}")
          else:
              print("没有新推文")

          # 保存状态
          with open(history_file, "w") as f:
              json.dump(tweet_ids, f)

          PYEOF

      - name: Save State
        if: always()
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add last_tweets.json 2>/dev/null || true
          git diff --cached --quiet || git commit -m "update state"
          git push || true
