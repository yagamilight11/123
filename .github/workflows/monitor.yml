name: Monitor

on:
  schedule:
    - cron: '*/2 * * * *'
  workflow_dispatch:

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Dependencies
        run: pip install selenium cryptography > /dev/null 2>&1

      - name: Setup Chrome
        uses: browser-actions/setup-chrome@v1
        with:
          chrome-version: stable

      - name: Setup ChromeDriver
        uses: nanasess/setup-chromedriver@v2

      - name: Check and Notify
        env:
          EMAIL_TO: ${{ secrets.EMAIL_TO }}
          EMAIL_FROM: ${{ secrets.EMAIL_FROM }}
          EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}
          TARGET_USER: ${{ secrets.TARGET_USER }}
          AUTH_TOKEN: ${{ secrets.AUTH_TOKEN }}
          CT0: ${{ secrets.CT0 }}
          FILE_PASSWORD: ${{ secrets.FILE_PASSWORD }}
        run: |
          python3 << 'PYEOF'
          import os
          import json
          import re
          import smtplib
          import time
          import hashlib
          import base64
          from email.mime.text import MIMEText
          from selenium import webdriver
          from selenium.webdriver.chrome.options import Options
          from selenium.webdriver.common.by import By
          from cryptography.fernet import Fernet

          target_user = os.environ.get("TARGET_USER", "")
          auth_token = os.environ.get("AUTH_TOKEN", "")
          ct0 = os.environ.get("CT0", "")
          file_password = os.environ.get("FILE_PASSWORD", "")

          # 加密工具
          def get_key(password):
              key = hashlib.sha256(password.encode()).digest()
              return base64.urlsafe_b64encode(key)

          def encrypt_data(data, password):
              f = Fernet(get_key(password))
              return f.encrypt(json.dumps(data).encode()).decode()

          def decrypt_data(encrypted, password):
              try:
                  f = Fernet(get_key(password))
                  return json.loads(f.decrypt(encrypted.encode()).decode())
              except:
                  return []

          def send_email(subject, body):
              email_to = os.environ.get("EMAIL_TO", "")
              email_from = os.environ.get("EMAIL_FROM", "")
              email_password = os.environ.get("EMAIL_PASSWORD", "")
              if email_to and email_from and email_password:
                  try:
                      msg = MIMEText(body, "plain", "utf-8")
                      msg["Subject"] = subject
                      msg["From"] = email_from
                      msg["To"] = email_to
                      server = smtplib.SMTP_SSL("smtp.gmail.com", 465)
                      server.login(email_from, email_password)
                      server.sendmail(email_from, email_to, msg.as_string())
                      server.quit()
                      print("邮件已发送")
                  except Exception as e:
                      print(f"邮件发送失败: {e}")

          # 用浏览器+Cookie访问
          options = Options()
          options.add_argument("--headless=new")
          options.add_argument("--no-sandbox")
          options.add_argument("--disable-dev-shm-usage")
          options.add_argument("--disable-gpu")
          options.add_argument("--disable-blink-features=AutomationControlled")
          options.add_argument("--window-size=1920,1080")
          options.add_argument("user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36")
          options.add_experimental_option("excludeSwitches", ["enable-automation"])

          driver = None
          tweet_ids = []
          cookie_works = False

          try:
              driver = webdriver.Chrome(options=options)
              driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")

              # 先访问x.com设置cookie
              print("正在设置Cookie...")
              driver.get("https://x.com")
              time.sleep(3)

              # 添加Cookie
              driver.add_cookie({"name": "auth_token", "value": auth_token, "domain": ".x.com"})
              driver.add_cookie({"name": "ct0", "value": ct0, "domain": ".x.com"})

              # 访问用户主页
              url = f"https://x.com/{target_user}"
              print(f"正在访问: {url}")
              driver.get(url)
              time.sleep(15)

              html = driver.page_source
              print(f"页面长度: {len(html)}")

              # 检查是否登录成功
              if "login" in html[:3000].lower() and len(html) < 400000:
                  print("仍然有登录墙，Cookie可能失效")
              else:
                  cookie_works = True

              # 提取推文ID - 多种方式
              # 方式1: 正则
              matches = re.findall(r'/status/(\d{18,25})', html)
              print(f"正则匹配数: {len(matches)}")

              # 方式2: 从a标签
              try:
                  links = driver.find_elements(By.CSS_SELECTOR, 'a[href*="/status/"]')
                  for link in links:
                      href = link.get_attribute("href") or ""
                      m = re.search(r'/status/(\d{18,25})', href)
                      if m:
                          matches.append(m.group(1))
                  print(f"链接匹配后总数: {len(matches)}")
              except Exception as e:
                  print(f"链接提取失败: {e}")

              # 方式3: 从article标签中的time元素附近找
              try:
                  articles = driver.find_elements(By.CSS_SELECTOR, 'article')
                  for article in articles:
                      article_html = article.get_attribute("innerHTML") or ""
                      article_matches = re.findall(r'/status/(\d{18,25})', article_html)
                      matches.extend(article_matches)
                  print(f"article匹配后总数: {len(matches)}")
              except Exception as e:
                  print(f"article提取失败: {e}")

              # 去重保留前5条
              seen = []
              for tid in matches:
                  if tid not in seen:
                      seen.append(tid)
                  if len(seen) >= 5:
                      break

              tweet_ids = seen
              print(f"最终推文ID: {tweet_ids}")

              if not tweet_ids and not cookie_works:
                  print("=== 页面片段(调试) ===")
                  print(html[:1500])

          except Exception as e:
              print(f"浏览器出错: {e}")
          finally:
              if driver:
                  driver.quit()

          # Cookie失效检测
          fail_file = "fail_count.json"
          fail_count = 0
          if os.path.exists(fail_file):
              try:
                  with open(fail_file, "r") as f:
                      fail_count = json.load(f).get("count", 0)
              except:
                  fail_count = 0

          if not tweet_ids:
              fail_count += 1
              print(f"未获取到推文，连续失败: {fail_count}")
              with open(fail_file, "w") as f:
                  json.dump({"count": fail_count}, f)

              if fail_count >= 5:
                  send_email(
                      "监控异常提醒",
                      "连续5次未获取到内容，Cookie可能已失效。\n\n请重新获取:\n1. 浏览器登录x.com\n2. F12 → Application → Cookies → x.com\n3. 复制 auth_token 和 ct0\n4. 去GitHub仓库 Settings → Secrets 更新"
                  )
                  with open(fail_file, "w") as f:
                      json.dump({"count": 0}, f)
              exit(0)

          # 成功，重置失败计数
          with open(fail_file, "w") as f:
              json.dump({"count": 0}, f)

          # 读取历史（加密文件）
          history_file = "history.enc"
          old_tweets = []
          first_run = False

          if os.path.exists(history_file):
              with open(history_file, "r") as f:
                  encrypted = f.read().strip()
                  if encrypted:
                      old_tweets = decrypt_data(encrypted, file_password)
          else:
              first_run = True

          print(f"上次推文ID: {old_tweets}")

          new_tweets = [t for t in tweet_ids if t not in old_tweets]
          should_send = first_run or len(new_tweets) > 0

          if should_send:
              links = [f"https://x.com/i/status/{tid}" for tid in (new_tweets if new_tweets else tweet_ids)]
              if first_run:
                  body = "监控已启动:\n\n" + "\n".join(links)
              else:
                  body = "检测到新内容:\n\n" + "\n".join(links)
              send_email("页面更新通知", body)

              # 同时保存到加密文件
              print("保存加密记录...")
          else:
              print("没有新推文")

          # 保存加密状态
          encrypted = encrypt_data(tweet_ids, file_password)
          with open(history_file, "w") as f:
              f.write(encrypted)
          print("加密记录已保存")

          PYEOF

      - name: Save State
        if: always()
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add history.enc fail_count.json 2>/dev/null || true
          git diff --cached --quiet || git commit -m "update"
          git push || true
