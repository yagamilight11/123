name: Monitor

on:
  schedule:
    - cron: '*/2 * * * *'
  workflow_dispatch:

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check and Notify
        env:
          EMAIL_TO: ${{ secrets.EMAIL_TO }}
          EMAIL_FROM: ${{ secrets.EMAIL_FROM }}
          EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}
          TARGET_USER: ${{ secrets.TARGET_USER }}
          AUTH_TOKEN: ${{ secrets.AUTH_TOKEN }}
          CT0: ${{ secrets.CT0 }}
        run: |
          python3 << 'PYEOF'
          import os
          import json
          import re
          import smtplib
          import urllib.request
          import urllib.parse
          from email.mime.text import MIMEText

          target_user = os.environ.get("TARGET_USER", "")
          auth_token = os.environ.get("AUTH_TOKEN", "")
          ct0 = os.environ.get("CT0", "")
          tweet_ids = []
          cookie_expired = False

          BEARER = "Bearer AAAAAAAAAAAAAAAAAAAAANRILgAAAAAAnNwIzUejRCOuH5E6I8xnZz4puTs%3D1Zv7ttfk8LF81IUq16cHjhLTvJu4FA33AGWWjCpTnA"

          def make_headers():
              return {
                  "Authorization": BEARER,
                  "Cookie": f"auth_token={auth_token}; ct0={ct0}",
                  "X-Csrf-Token": ct0,
                  "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
                  "Content-Type": "application/json",
                  "X-Twitter-Active-User": "yes",
                  "X-Twitter-Client-Language": "en",
              }

          def send_email(subject, body):
              email_to = os.environ.get("EMAIL_TO", "")
              email_from = os.environ.get("EMAIL_FROM", "")
              email_password = os.environ.get("EMAIL_PASSWORD", "")
              if email_to and email_from and email_password:
                  try:
                      msg = MIMEText(body, "plain", "utf-8")
                      msg["Subject"] = subject
                      msg["From"] = email_from
                      msg["To"] = email_to
                      server = smtplib.SMTP_SSL("smtp.gmail.com", 465)
                      server.login(email_from, email_password)
                      server.sendmail(email_from, email_to, msg.as_string())
                      server.quit()
                      print("邮件已发送")
                      return True
                  except Exception as e:
                      print(f"邮件发送失败: {e}")
                      return False
              return False

          # 方法1: v2 API
          def try_v2_api(user_id):
              print("尝试 v2 API...")
              url = f"https://api.twitter.com/2/users/{user_id}/tweets?max_results=5&tweet.fields=created_at"
              try:
                  req = urllib.request.Request(url, headers=make_headers())
                  resp = urllib.request.urlopen(req, timeout=30)
                  data = json.loads(resp.read().decode("utf-8"))
                  ids = [t["id"] for t in data.get("data", [])]
                  print(f"v2 API 获取到: {ids}")
                  return ids
              except urllib.error.HTTPError as e:
                  print(f"v2 API 失败: HTTP {e.code}")
                  if e.code in [401, 403]:
                      return "EXPIRED"
                  return []
              except Exception as e:
                  print(f"v2 API 失败: {e}")
                  return []

          # 方法2: v1.1 API
          def try_v1_api(user_id):
              print("尝试 v1.1 API...")
              url = f"https://api.twitter.com/1.1/statuses/user_timeline.json?user_id={user_id}&count=5&include_rts=true"
              try:
                  req = urllib.request.Request(url, headers=make_headers())
                  resp = urllib.request.urlopen(req, timeout=30)
                  data = json.loads(resp.read().decode("utf-8"))
                  ids = [str(t["id"]) for t in data]
                  print(f"v1.1 API 获取到: {ids}")
                  return ids
              except urllib.error.HTTPError as e:
                  print(f"v1.1 API 失败: HTTP {e.code}")
                  if e.code in [401, 403]:
                      return "EXPIRED"
                  return []
              except Exception as e:
                  print(f"v1.1 API 失败: {e}")
                  return []

          # 方法3: GraphQL UserTweets
          def try_graphql(user_id):
              print("尝试 GraphQL API...")
              variables = {
                  "userId": user_id,
                  "count": 5,
                  "includePromotedContent": False,
                  "withQuickPromoteEligibilityTweetFields": True,
                  "withVoice": True,
                  "withV2Timeline": True
              }
              features = {
                  "rweb_tipjar_consumption_enabled": True,
                  "responsive_web_graphql_exclude_directive_enabled": True,
                  "verified_phone_label_enabled": False,
                  "creator_subscriptions_tweet_preview_api_enabled": True,
                  "responsive_web_graphql_timeline_navigation_enabled": True,
                  "responsive_web_graphql_skip_user_profile_image_extensions_enabled": False,
                  "communities_web_enable_tweet_community_results_fetch": True,
                  "c9s_tweet_anatomy_moderator_badge_enabled": True,
                  "articles_preview_enabled": True,
                  "responsive_web_edit_tweet_api_enabled": True,
                  "graphql_is_translatable_rweb_tweet_is_translatable_enabled": True,
                  "view_counts_everywhere_api_enabled": True,
                  "longform_notetweets_consumption_enabled": True,
                  "responsive_web_twitter_article_tweet_consumption_enabled": True,
                  "tweet_awards_web_tipping_enabled": False,
                  "creator_subscriptions_quote_tweet_preview_enabled": False,
                  "freedom_of_speech_not_reach_fetch_enabled": True,
                  "standardized_nudges_misinfo": True,
                  "tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled": True,
                  "rweb_video_timestamps_enabled": True,
                  "longform_notetweets_rich_text_read_enabled": True,
                  "longform_notetweets_inline_media_enabled": True,
                  "responsive_web_enhance_cards_enabled": False
              }
              
              v_str = urllib.parse.quote(json.dumps(variables))
              f_str = urllib.parse.quote(json.dumps(features))
              
              # 尝试多个已知的 GraphQL endpoint
              endpoints = [
                  "V7H0Ap3_Hh2FyS75OCDO3Q",
                  "CdG2Vuc1v6F5JyEngGpxVw",
                  "WzJjibAcDa-oCjCcLOotcg",
                  "eS7LO5Jy3xgmd3dbL044EA",
              ]
              
              for ep in endpoints:
                  try:
                      url = f"https://api.twitter.com/graphql/{ep}/UserTweets?variables={v_str}&features={f_str}"
                      req = urllib.request.Request(url, headers=make_headers())
                      resp = urllib.request.urlopen(req, timeout=30)
                      data = json.loads(resp.read().decode("utf-8"))
                      text = json.dumps(data)
                      
                      # 提取推文ID
                      matches = re.findall(r'"rest_id"\s*:\s*"(\d{18,25})"', text)
                      
                      # 过滤：排除用户ID本身
                      filtered = []
                      for m in matches:
                          if m != user_id and m not in filtered:
                              filtered.append(m)
                          if len(filtered) >= 5:
                              break
                      
                      if filtered:
                          print(f"GraphQL endpoint {ep} 成功: {filtered}")
                          return filtered
                      else:
                          print(f"GraphQL endpoint {ep} 无推文")
                  except urllib.error.HTTPError as e:
                      print(f"GraphQL endpoint {ep} 失败: HTTP {e.code}")
                      if e.code in [401, 403]:
                          return "EXPIRED"
                  except Exception as e:
                      print(f"GraphQL endpoint {ep} 失败: {e}")
              return []

          # 获取用户ID
          print("=== 获取用户ID ===")
          user_id = "1588419108147560448"
          print(f"用户ID: {user_id}")

          # 依次尝试3种方法
          print("\n=== 方法1: v2 API ===")
          result = try_v2_api(user_id)

          if result == "EXPIRED":
              cookie_expired = True
          elif result:
              tweet_ids = result
          else:
              print("\n=== 方法2: v1.1 API ===")
              result = try_v1_api(user_id)
              
              if result == "EXPIRED":
                  cookie_expired = True
              elif result:
                  tweet_ids = result
              else:
                  print("\n=== 方法3: GraphQL API ===")
                  result = try_graphql(user_id)
                  
                  if result == "EXPIRED":
                      cookie_expired = True
                  elif result:
                      tweet_ids = result

          print(f"\n最终推文ID: {tweet_ids}")

          # Cookie失效处理
          if cookie_expired:
              fail_file = "fail_count.json"
              fail_count = 0
              if os.path.exists(fail_file):
                  with open(fail_file, "r") as f:
                      fail_count = json.load(f).get("count", 0)
              
              fail_count += 1
              print(f"认证失败，连续失败次数: {fail_count}")
              
              if fail_count >= 3:
                  send_email(
                      "监控异常提醒",
                      "认证信息可能已失效，请重新获取:\n\n1. 浏览器登录x.com\n2. F12 → Application → Cookies → x.com\n3. 复制 auth_token 和 ct0\n4. 去GitHub仓库 Settings → Secrets 更新\n\n更新后监控会自动恢复。"
                  )
                  fail_count = 0
              
              with open(fail_file, "w") as f:
                  json.dump({"count": fail_count}, f)
              exit(0)
          
          # 重置失败计数
          fail_file = "fail_count.json"
          with open(fail_file, "w") as f:
              json.dump({"count": 0}, f)

          if not tweet_ids:
              print("未获取到推文")
              exit(0)

          # 读取历史
          history_file = "last_tweets.json"
          old_tweets = []
          first_run = False

          if os.path.exists(history_file):
              with open(history_file, "r") as f:
                  old_tweets = json.load(f)
          else:
              first_run = True

          print(f"上次推文ID: {old_tweets}")

          new_tweets = [t for t in tweet_ids if t not in old_tweets]
          should_send = first_run or len(new_tweets) > 0

          if should_send:
              links = [f"https://x.com/i/status/{tid}" for tid in (new_tweets if new_tweets else tweet_ids)]
              if first_run:
                  body = "监控已启动:\n\n" + "\n".join(links)
              else:
                  body = "检测到新内容:\n\n" + "\n".join(links)
              send_email("页面更新通知", body)
          else:
              print("没有新推文")

          # 保存状态
          with open(history_file, "w") as f:
              json.dump(tweet_ids, f)

          PYEOF

      - name: Save State
        if: always()
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add last_tweets.json fail_count.json 2>/dev/null || true
          git diff --cached --quiet || git commit -m "update state"
          git push || true
