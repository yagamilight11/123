name: Monitor

on:
  schedule:
    - cron: '*/2 * * * *'
  workflow_dispatch:

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Dependencies
        run: |
          pip install selenium > /dev/null 2>&1
          sudo apt-get install -y minizip > /dev/null 2>&1

      - name: Setup Chrome
        uses: browser-actions/setup-chrome@v1
        with:
          chrome-version: stable

      - name: Setup ChromeDriver
        uses: nanasess/setup-chromedriver@v2

      - name: Check and Save
        env:
          TARGET_USER: ${{ secrets.TARGET_USER }}
          AUTH_TOKEN: ${{ secrets.AUTH_TOKEN }}
          CT0: ${{ secrets.CT0 }}
          FILE_PASSWORD: ${{ secrets.FILE_PASSWORD }}
          EMAIL_TO: ${{ secrets.EMAIL_TO }}
          EMAIL_FROM: ${{ secrets.EMAIL_FROM }}
          EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}
        run: |
          python3 << 'PYEOF'
          import os
          import json
          import re
          import time
          import subprocess
          import smtplib
          from datetime import datetime, timezone, timedelta
          from email.mime.text import MIMEText
          from selenium import webdriver
          from selenium.webdriver.chrome.options import Options
          from selenium.webdriver.common.by import By

          target_user = os.environ.get("TARGET_USER", "")
          auth_token = os.environ.get("AUTH_TOKEN", "")
          ct0 = os.environ.get("CT0", "")
          file_password = os.environ.get("FILE_PASSWORD", "")

          now = datetime.now(timezone(timedelta(hours=8))).strftime("%Y-%m-%d %H:%M:%S")

          def send_alert(reason, detail):
              email_to = os.environ.get("EMAIL_TO", "")
              email_from = os.environ.get("EMAIL_FROM", "")
              email_password = os.environ.get("EMAIL_PASSWORD", "")
              if not (email_to and email_from and email_password):
                  return
              body = f"监控异常通知\n\n时间: {now}\n\n异常原因: {reason}\n\n详细信息: {detail}\n\n处理方式: 请根据以上原因进行修复。如果是Cookie失效，请重新获取auth_token和ct0并更新GitHub Secrets。"
              try:
                  msg = MIMEText(body, "plain", "utf-8")
                  msg["Subject"] = f"监控异常: {reason}"
                  msg["From"] = email_from
                  msg["To"] = email_to
                  server = smtplib.SMTP_SSL("smtp.gmail.com", 465)
                  server.login(email_from, email_password)
                  server.sendmail(email_from, email_to, msg.as_string())
                  server.quit()
                  print(f"告警邮件已发送: {reason}")
              except Exception as e:
                  print(f"告警邮件发送失败: {e}")

          # 读取失败计数
          fail_file = "fail_count.json"
          fail_data = {"count": 0, "last_alert": "", "alert_reasons": []}
          if os.path.exists(fail_file):
              try:
                  with open(fail_file, "r") as f:
                      fail_data = json.load(f)
              except:
                  pass

          fail_count = fail_data.get("count", 0)
          last_alert = fail_data.get("last_alert", "")
          alert_reasons = fail_data.get("alert_reasons", [])

          # 读取历史直播记录
          history_file = "history.json"
          zip_file = "data.zip"
          old_data = {"broadcasts": [], "last_check": "", "status": ""}

          if os.path.exists(zip_file):
              try:
                  subprocess.run(
                      ["unzip", "-P", file_password, "-o", zip_file],
                      capture_output=True, timeout=10
                  )
                  if os.path.exists(history_file):
                      with open(history_file, "r") as f:
                          old_data = json.load(f)
                      print("成功读取历史记录")
              except Exception as e:
                  print(f"解密旧文件失败: {e}")

          old_broadcasts = old_data.get("broadcasts", [])
          old_broadcast_urls = [b["url"] for b in old_broadcasts]

          # 浏览器访问
          options = Options()
          options.add_argument("--headless=new")
          options.add_argument("--no-sandbox")
          options.add_argument("--disable-dev-shm-usage")
          options.add_argument("--disable-gpu")
          options.add_argument("--disable-blink-features=AutomationControlled")
          options.add_argument("--window-size=1920,1080")
          options.add_argument("user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36")
          options.add_experimental_option("excludeSwitches", ["enable-automation"])

          driver = None
          broadcast_links = []
          error_reason = ""
          status = "unknown"
          page_ok = False

          try:
              driver = webdriver.Chrome(options=options)
              driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")

              print("正在设置Cookie...")
              driver.get("https://x.com")
              time.sleep(3)

              if not auth_token or not ct0:
                  error_reason = "Cookie未配置"
                  status = "异常: Cookie未配置"
                  print(status)
              else:
                  driver.add_cookie({"name": "auth_token", "value": auth_token, "domain": ".x.com"})
                  driver.add_cookie({"name": "ct0", "value": ct0, "domain": ".x.com"})

                  url = f"https://x.com/{target_user}"
                  print(f"正在访问: {url}")
                  driver.get(url)
                  time.sleep(15)

                  html = driver.page_source
                  page_len = len(html)
                  print(f"页面长度: {page_len}")

                  html_lower = html[:5000].lower()

                  if page_len < 10000:
                      error_reason = "页面内容过短，可能被封锁"
                      status = f"异常: 页面仅{page_len}字节"
                  elif "account suspended" in html_lower:
                      error_reason = "目标账号已被封禁"
                      status = "异常: 目标账号被封禁"
                  elif "doesn't exist" in html_lower:
                      error_reason = "目标账号不存在或已注销"
                      status = "异常: 目标账号不存在"
                  elif "rate limit" in html_lower or "try again later" in html_lower:
                      error_reason = "访问频率受限，被X限流"
                      status = "异常: 被限流"
                  elif ("login" in html_lower or "sign in" in html_lower) and "logout" not in html_lower:
                      error_reason = "Cookie已失效，需要重新获取auth_token和ct0"
                      status = "异常: Cookie失效"
                  else:
                      page_ok = True
                      status = "正常运行中"

                      # 只提取 broadcast 链接
                      # 方式1: 正则匹配所有broadcast链接
                      broadcast_matches = re.findall(r'https?://[^\s"\'<>]*broadcast[^\s"\'<>]*', html, re.IGNORECASE)
                      print(f"正则broadcast匹配数: {len(broadcast_matches)}")

                      # 方式2: 从a标签提取
                      try:
                          all_links = driver.find_elements(By.CSS_SELECTOR, 'a[href*="broadcast"]')
                          for link in all_links:
                              href = link.get_attribute("href") or ""
                              if href and "broadcast" in href.lower():
                                  broadcast_matches.append(href)
                          print(f"a标签broadcast匹配数: {len(broadcast_matches)}")
                      except:
                          pass

                      # 方式3: 从article中提取
                      try:
                          articles = driver.find_elements(By.CSS_SELECTOR, 'article')
                          for article in articles:
                              article_html = article.get_attribute("innerHTML") or ""
                              article_broadcasts = re.findall(r'https?://[^\s"\'<>]*broadcast[^\s"\'<>]*', article_html, re.IGNORECASE)
                              broadcast_matches.extend(article_broadcasts)
                          print(f"article broadcast匹配数: {len(broadcast_matches)}")
                      except:
                          pass

                      # 去重
                      seen = []
                      for link in broadcast_matches:
                          # 清理链接
                          link = link.strip().rstrip('\\').rstrip('"').rstrip("'")
                          if link not in seen:
                              seen.append(link)

                      broadcast_links = seen
                      print(f"最终broadcast链接: {broadcast_links}")

                  if error_reason:
                      print(status)

          except Exception as e:
              error_reason = f"浏览器运行出错: {str(e)}"
              status = f"异常: {error_reason}"
              print(status)
          finally:
              if driver:
                  driver.quit()

          # 异常告警
          if error_reason:
              fail_count += 1
              print(f"连续失败次数: {fail_count}")
              if error_reason not in alert_reasons:
                  alert_reasons.append(error_reason)
              if fail_count == 5 or (fail_count > 5 and fail_count % 50 == 0):
                  all_reasons = "\n".join([f"  - {r}" for r in alert_reasons])
                  send_alert(error_reason, f"连续失败次数: {fail_count}\n\n出现过的异常:\n{all_reasons}")
                  last_alert = now
              fail_data = {"count": fail_count, "last_alert": last_alert, "alert_reasons": alert_reasons}
          else:
              if fail_count > 0:
                  print(f"恢复正常！之前连续失败了{fail_count}次")
              fail_data = {"count": 0, "last_alert": "", "alert_reasons": []}

          with open(fail_file, "w") as f:
              json.dump(fail_data, f, ensure_ascii=False)

          # 处理直播链接
          if broadcast_links:
              new_broadcasts = [b for b in broadcast_links if b not in old_broadcast_urls]
              if new_broadcasts:
                  print(f"发现 {len(new_broadcasts)} 个新直播链接!")
                  for b in new_broadcasts:
                      old_broadcasts.append({
                          "time": now,
                          "url": b
                      })
              else:
                  print("直播链接已记录过")
          else:
              if page_ok:
                  print("当前没有直播")
              
          # 保存数据
          save_data = {
              "broadcasts": old_broadcasts,
              "last_check": now,
              "status": status
          }

          with open(history_file, "w") as f:
              json.dump(save_data, f, ensure_ascii=False, indent=2)

          if os.path.exists(zip_file):
              os.remove(zip_file)

          result = subprocess.run(
              ["minizip", "-P", file_password, zip_file, history_file],
              capture_output=True, text=True, timeout=10
          )
          if result.returncode != 0:
              subprocess.run(
                  ["7z", "a", f"-p{file_password}", "-y", zip_file, history_file],
                  capture_output=True, text=True, timeout=10
              )

          if os.path.exists(history_file):
              os.remove(history_file)

          print(f"\n状态: {status}")
          print(f"时间: {now}")
          print(f"历史直播记录数: {len(old_broadcasts)}")

          PYEOF

      - name: Save to Repo
        if: always()
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add data.zip fail_count.json 2>/dev/null || true
          git add -u 2>/dev/null || true
          git diff --cached --quiet || git commit -m "update"
          git push || true
